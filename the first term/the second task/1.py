import matplotlib.pyplot as plt

def dydx(x, y):
    return x * x + y * y

T = 1.0
x_0 = 2.0
y_0 = 1.0

y = y_0
tau = 0.000001
N = int(T / tau)
x0 = x_0

for i in range(1, N + 1):
    k1 = dydx(x0, y)

    k2 = dydx(x0 + 0.2 * tau, y + tau * (0.2 * k1))

    k3 = dydx(x0 + 0.3 * tau,
                  y + tau * ((3.0 / 40.0) * k1 + (9.0 / 40.0) * k2))

    k4 = dydx(x0 + 0.8 * tau,
                  y + tau * ((44.0 / 45.0) * k1 +
                             (-56.0 / 15.0) * k2 +
                             (32.0 / 9.0) * k3))

    k5 = dydx(x0 + (8.0 / 9.0) * tau,
                  y + tau * ((19372.0 / 6561.0) * k1 +
                             (-25360.0 / 2187.0) * k2 +
                             (64448.0 / 6561.0) * k3 +
                             (-212.0 / 729.0) * k4))

    k6 = dydx(x0 + tau,
                  y + tau * ((9017.0 / 3168.0) * k1 +
                             (-355.0 / 33.0) * k2 +
                             (46732.0 / 5247.0) * k3 +
                             (49.0 / 176.0) * k4 +
                             (-5103.0 / 18656.0) * k5))

    k7 = dydx(x0 + tau,
                  y + tau * ((35.0 / 384.0) * k1 +
                             (500.0 / 1113.0) * k3 +
                             (125.0 / 192.0) * k4 +
                             (-2187.0 / 6784.0) * k5 +
                             (11.0 / 84.0) * k6))


    y -= tau * ((35.0 / 384.0) * k1 +
                    (500.0 / 1113.0) * k3 +
                    (125.0 / 192.0) * k4 +
                    (-2187.0 / 6784.0) * k5 +
                    (11.0 / 84.0) * k6)

    x0 -= tau

print("При шаге 0.000001 методом Дорманда-Принса y(1) =", y)

x_array = []
y_array = []

T = 1.0
x_0 = 2.0
y_0 = 1.0

y = y_0
tau = 0.0000001
N = int(T / tau)
x0 = x_0

for i in range(1, N + 1):
    x_array.append(x0)
    y_array.append(y)

    k1 = dydx(x0, y)

    k2 = dydx(x0 + 0.2 * tau, y + tau * (0.2 * k1))

    k3 = dydx(x0 + 0.3 * tau,
                  y + tau * ((3.0 / 40.0) * k1 + (9.0 / 40.0) * k2))

    k4 = dydx(x0 + 0.8 * tau,
                  y + tau * ((44.0 / 45.0) * k1 +
                             (-56.0 / 15.0) * k2 +
                             (32.0 / 9.0) * k3))

    k5 = dydx(x0 + (8.0 / 9.0) * tau,
                  y + tau * ((19372.0 / 6561.0) * k1 +
                             (-25360.0 / 2187.0) * k2 +
                             (64448.0 / 6561.0) * k3 +
                             (-212.0 / 729.0) * k4))

    k6 = dydx(x0 + tau,
                  y + tau * ((9017.0 / 3168.0) * k1 +
                             (-355.0 / 33.0) * k2 +
                             (46732.0 / 5247.0) * k3 +
                             (49.0 / 176.0) * k4 +
                             (-5103.0 / 18656.0) * k5))

    k7 = dydx(x0 + tau,
                  y + tau * ((35.0 / 384.0) * k1 +
                             (500.0 / 1113.0) * k3 +
                             (125.0 / 192.0) * k4 +
                             (-2187.0 / 6784.0) * k5 +
                             (11.0 / 84.0) * k6))


    y -= tau * ((35.0 / 384.0) * k1 +
                    (500.0 / 1113.0) * k3 +
                    (125.0 / 192.0) * k4 +
                    (-2187.0 / 6784.0) * k5 +
                    (11.0 / 84.0) * k6)

    x0 -= tau
print("При шаге 0.0000001 методом Дорманда-Принса y(1) =", y)

def dydx(x, y):
    return x ** 2 + y ** 2

def rungeKutta(x0, y0, x, h):
    n = (int)(abs(x - x0)/h)
    y = y0
    for i in range(1, n + 1):
        k1 = h * dydx(x0, y)
        k2 = h * dydx(x0 + 0.5 * h, y + 0.5 * k1)
        k3 = h * dydx(x0 + 0.5 * h, y + 0.5 * k2)
        k4 = h * dydx(x0 + h, y + k3)

        y = y - (1.0 / 6.0)*(k1 + 2 * k2 + 2 * k3 + k4)

        x0 = x0 - h
    return y


x0 = 2
y = 1
x = 1
h1 = 0.000001
print('При шаге 0.000001 другим методом с меньшим порядком аппроксимации y(1) =', rungeKutta(x0, y, x, h1))
h2 = 0.0000001
print('При шаге 0.0000001 другим методом с меньшим порядком аппроксимации y(1) =', rungeKutta(x0, y, x, h2))
print("При уменьшении шага разными методами получается тот же результат до четвёртого знака после запятой. Значит, решение находится с заданной точностью и сходится (при уменьшении шага, считая решение методом Дорманда-Принса более высокого порядка, видим, что ошибка уменьшается).")
plt.plot(x_array, y_array)
plt.show()